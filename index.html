<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Web3Final</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.22.0/dist/phaser.min.js"></script>
</head>
<body>
    <script>
        //Todd Vogel created this game.
        var BootScene = new Phaser.Class({
        
            Extends: Phaser.Scene,

            initialize:

            function BootScene ()
            {
                Phaser.Scene.call(this, { key: 'BootScene' });
            },

            preload: function ()
            {
                // load the resources here
                // map tiles
                this.load.image('tiles', 'assets/Map/spritesheet.png');
                
                // map in json format
                this.load.tilemapTiledJSON('map', 'assets/Map/Map1.json');

                //Load start screen image
                this.load.image('start', 'assets/sky.png');

                // our character + other random characters
                this.load.spritesheet('player', 'assets/sprites32x32.png', { frameWidth: 32, frameHeight: 32 });
                //Load small enemies
                this.load.spritesheet("rat","assets/Small/rat.png", {frameWidth: 64, frameHeight: 64});
                this.load.spritesheet("dune", "assets/Small/dune_crawler.png", {frameWidth: 64, frameHeight: 64});
                this.load.spritesheet("slime", "assets/Small/green_slime.png", {frameWidth: 64, frameHeight: 64});
                this.load.spritesheet("scorpion", "assets/Small/scorpion.png", {frameWidth: 64, frameHeight: 64});
                this.load.spritesheet("spider", "assets/Small/spider.png", {frameWidth: 64, frameHeight: 64});
                //Load medium enemies
                this.load.spritesheet("bat", "assets/Medium/bat.png", {frameWidth: 128, frameHeight: 128});
                this.load.spritesheet("demon", "assets/Medium/demon.png", {frameWidth: 128, frameHeight: 192});
                this.load.spritesheet("skeleton", "assets/Medium/skeleton.png", {frameWidth: 64, frameHeight: 128});
                this.load.spritesheet("snake", "assets/Medium/snake.png", {frameWidth: 128, frameHeight: 64});
                this.load.spritesheet("tree", "assets/Medium/tree.png", {frameWidth:128, frameHeight: 128});
                //Load large enemies
                this.load.spritesheet("deceleon", "assets/Large/deceleon.png", {frameWidth: 256, frameHeight: 256});
                this.load.spritesheet("drake", "assets/Large/drake.png", {frameWidth: 192, frameHeight: 256});
                this.load.spritesheet("horror", "assets/Large/horror.png", {frameWidth: 192, frameHeight: 192});
                this.load.spritesheet("lizard", "assets/Large/lizard.png", {frameWidth: 192, frameHeight: 192});
                this.load.spritesheet("nagaruda", "assets/Large/nagaruda.png", {frameWidth: 192, frameHeight: 256});
                //Load Boss
                this.load.spritesheet("aurum", "assets/Large/aurum.png", {frameWidth: 320, frameHeight: 256});
                //Load Music
                this.load.audio("Start", "assets/Music/Start.ogg");
                this.load.audio("World", "assets/Music/World.ogg");
                this.load.audio("Battle", "assets/Music/Battle.ogg");
                this.load.audio("Boss", "assets/Music/Boss.ogg");
                this.load.audio("GameOver", "assets/Music/GameOver.ogg");
                //Load SFX
                this.load.audio("Attack", "assets/SFX/attack.wav");
                this.load.audio("Spell", "assets/SFX/spell.wav");
                this.load.audio("Select", "assets/SFX/select.wav");
                this.load.audio("Confirm", "assets/SFX/confirm.wav");
                this.load.audio("Back", "assets/SFX/back.wav");
            },

            create: function ()
            {
                this.cameras.main.flash(2000);
                this.soundFX = this.sound.add("Start", {loop: "true"});
                this.soundFX.setVolume(0.5);
                this.soundFX.play();
                this.cameras.main.setBackgroundColor('rgba(0, 200, 0, 0.5)');
                this.add.image(0, 0, 'start').setOrigin(0,0);
                this.add.text(80, 200, "Web 3 Project", {fontSize: '60px', fill: "#0b1f01"})
                this.add.text(100, 300, "Press any key to start.", {fontSize: '30px', fill: "#0b1f01"});
                this.input.keyboard.on('keydown', this.fade, this);
            },
            fade: function() {
                this.cameras.main.fadeOut(1000);
                var twait = this.time.addEvent({delay: 1000, callback: this.startGame, callbackScope: this});
            },
            startGame: function() {
                this.soundFX.stop();
                this.scene.start('WorldScene');
            }
        });

        var WorldScene = new Phaser.Class({

            Extends: Phaser.Scene,

            initialize:

            function WorldScene ()
            {
                Phaser.Scene.call(this, { key: 'WorldScene' });
            },
            preload: function ()
            {
                
            },
            create: function ()
            {
                this.cameras.main.fadeIn(500);
                this.soundFX = this.sound.add("World", {loop: "true"});
                this.soundFX.setVolume(0.5);
                this.soundFX.play();
                // create world
                var map = this.make.tilemap({ key: 'map' });

                var tiles = map.addTilesetImage('spritesheet', 'tiles');
                        
                var background = map.createStaticLayer('Background', tiles, 0, 0);
                var obstacles = map.createStaticLayer('Blocked', tiles, 0, 0);
                obstacles.setCollisionByExclusion([-1]);

                this.player = this.physics.add.sprite(550, 550, 'player', 97); //Player sprite

                this.physics.world.bounds.width = map.widthInPixels; //Map borders
                this.physics.world.bounds.height = map.heightInPixels;
                this.player.setCollideWorldBounds(true);

                this.cursors = this.input.keyboard.createCursorKeys(); //Allow input

                this.cameras.main.setBounds(0, 0, map.widthInPixels, map.heightInPixels); //Set up bounds for map
                this.cameras.main.startFollow(this.player);
                this.cameras.main.roundPixels = true;

                //Animations for player
                this.anims.create({ //Animation left
                    key: 'left',
                    frames: this.anims.generateFrameNumbers('player', { frames: [105, 104, 105, 106]}),
                    frameRate: 10,
                    repeat: -1
                });
                this.anims.create({ //Animation right
                    key: 'right',
                    frames: this.anims.generateFrameNumbers('player', { frames: [104, 105, 106, 105] }),
                    frameRate: 10,
                    repeat: -1
                }); 
                this.anims.create({ //Animation up
                    key: 'up',
                    frames: this.anims.generateFrameNumbers('player', { frames: [101, 100, 102, 100]}),
                    frameRate: 10,
                    repeat: -1
                });
                this.anims.create({ //Animation down
                    key: 'down',
                    frames: this.anims.generateFrameNumbers('player', { frames: [ 97, 96, 97, 98 ] }),
                    frameRate: 10,
                    repeat: -1
                });
                this.physics.add.collider(this.player, obstacles); //Collision

                this.spawns = this.physics.add.group({ classType: Phaser.GameObjects.Zone }); //invisible enemy generation
                for(var i = 1; i <= 6; i++) {
                    var x = i * 100;
                    for(var j = 1; j <=6; j++){
                        var y = 100 * j;
                        this.spawns.create(x, y, 20, 20);
                    }         
                }        
                this.physics.add.overlap(this.player, this.spawns, this.onMeetEnemy, false, this); //If player touches enemy
                this.sys.events.on('wake', this.wake, this);
            },
            update: function move (time, delta) //Allow movement
            {
                this.player.body.setVelocity(0);
            
                // Horizontal movement
                if (this.cursors.left.isDown)
                {
                    this.player.body.setVelocityX(-80);
                    this.player.flipX = true;
                    this.player.anims.play('left', true);
                }
                else if (this.cursors.right.isDown)
                {
                    this.player.body.setVelocityX(80);
                    this.player.flipX = false;
                    this.player.anims.play('right', true);
                }
                else if (!this.cursors.down.isDown && !this.cursors.up.isDown && !this.cursors.right.isDown && !this.cursors.left.isDown) //No movement, no animation
                {
                    this.player.anims.stop();
                } 

                if (this.cursors.up.isDown) // Vertical movement
                {
                    this.player.body.setVelocityY(-80); //Not changing flipX cause it doesn't really matter with vertical movement.
                    this.player.anims.play('up', true);
                }
                else if (this.cursors.down.isDown)
                {
                    this.player.body.setVelocityY(80);
                    this.player.anims.play('down', true);
                }   
                else if (!this.cursors.down.isDown && !this.cursors.up.isDown && !this.cursors.right.isDown && !this.cursors.left.isDown) //No movement, no animation
                {
                    this.player.anims.stop();
                } 
            },
            
            onMeetEnemy: function(player, zone) {
                //Destroy enemy
                zone.destroy();
                // shake the world
                this.cameras.main.shake(300);
                this.cameras.main.fadeOut(300);
                var timeEvent = this.time.addEvent({delay: 300, callback: this.battleStart, callbackScope: this}); //Start battle
            },

            wake: function() {
                this.cursors.left.reset();
                this.cursors.right.reset();
                this.cursors.up.reset();
                this.cursors.down.reset();
                this.cameras.main.fadeIn(300);
                this.soundFX.play();
            },

            battleStart: function() {
                this.soundFX.stop();
                this.scene.switch('BattleScene');
            }
        });

        var BattleScene = new Phaser.Class({
 
            Extends: Phaser.Scene,

            initialize:

            function BattleScene ()
            {
                Phaser.Scene.call(this, { key: 'BattleScene' });
            },
            create: function ()
            {
                this.cameras.main.setBackgroundColor('rgba(0, 200, 0, 0.5)');
                this.cameras.main.fadeIn(300);
                this.soundFX = this.sound.add("Battle", {loop: "true"});
                this.soundFX.setVolume(0.5);
                this.soundFX.play();
                player = new PlayerCharacter(this, 100, 200, 'player', 105, 'Battlemage', 100, 20);
                this.add.existing(player);
                hpText = this.add.text(50, 250, 'HP: 100', { fontSize: '30px', fill: '#000' })
                this.startBattle();
                // on wake event we call startBattle too
                this.sys.events.on('wake', this.wake, this);
            },

            exitBattle: function() {
                this.soundFX.stop();
                this.scene.sleep('UIScene');
                this.scene.switch('WorldScene');
            },

            wake: function() {
                this.cameras.main.fadeIn(300);
                this.soundFX.play();
                this.startBattle();          
            },

            startBattle: function() {
                //Add enemies, hardcoded for now. Trying out some new enemies and positioning.
                //var eRat = new Enemy(this, 400, 100, 'rat', 0, 'Dire Rat', 10, 15, 1);
                //this.add.existing(eRat);
                //var eScor = new Enemy(this, 400, 300, 'scorpion', 0, 'Dire Scorpion', 30, 10, 1);
                //this.add.existing(eScor);
                //var eSlime = new Enemy(this, 550, 200, 'slime', 0, 'Slime', 50, 5, 1);
                //this.add.existing(eSlime);
                //var eDune = new Enemy(this, 400, 100, 'dune', 0, 'Dune Crawler', 35, 5, 1);
                //this.add.existing(eDune);
                //var eSpider = new Enemy(this, 550, 200, 'spider', 0, 'Giant Spider', 20, 20, 1);
                //this.add.existing(eSpider);
                //var eBat = new Enemy(this, 400, 300, 'bat', 0, 'Dire Bat', 20, 15, 2);
                //this.add.existing(eBat);
                //var eSkel = new Enemy(this, 400, 100, 'skeleton', 0, 'Skeleton', 10, 20, 2);
                //this.add.existing(eSkel);
                //var eSnake = new Enemy(this, 400, 300, 'snake', 0, 'Dire Snake', 20, 10, 2);
                //this.add.existing(eSnake);
                //var eDemon = new Enemy(this, 0, 0, 'demon', 0, 'Demon', 50, 10, 2);
                //this.add.existing(eDemon);
                //var eTree = new Enemy(this, 550, 200, 'tree', 0, 'Haunted Tree', 60, 5, 2);
                //this.add.existing(eTree);
                //var eDec = new Enemy(this, 0, 0, 'deceleon', 0, 'Deceleon', 100, 10, 3);
                //this.add.existing(eDec);
                //var eDrake = new Enemy(this, 0, 0, 'drake', 0, 'Drake', 100, 10, 3);
                //this.add.existing(eDrake);
                //var eHorror = new Enemy(this, 0, 0, 'horror', 0, 'Elder Horror', 100, 10, 3);
                //this.add.existing(eHorror);
                //var eLizard = new Enemy(this, 0, 0, 'lizard', 0, 'Lizard Beast', 100, 10, 3);
                //this.add.existing(eLizard);
                //var eNaga = new Enemy(this, 0, 0, 'nagaruda', 0, 'Nagaruda', 100, 10, 3);
                //this.add.existing(eNaga);
                //var eAurum = new Enemy(this, 400, 200, 'aurum', 0, 'Aurum', 500, 50, 4);
                //this.add.existing(eAurum);

                var rng = Phaser.Math.Between(1, 3);
                if(rng == 1) {
                    var eRat = new Enemy(this, 400, 100, 'rat', 0, 'Dire Rat', 10, 15, 1);
                    this.add.existing(eRat);
                    var eScor = new Enemy(this, 400, 300, 'scorpion', 0, 'Dire Scorpion', 30, 10, 1);
                    this.add.existing(eScor);
                    var eSlime = new Enemy(this, 550, 200, 'slime', 0, 'Slime', 50, 5, 1);
                    this.add.existing(eSlime);
                    this.enemies = [eRat, eScor, eSlime];
                }
                else if (rng == 2){
                    var eSkel = new Enemy(this, 400, 100, 'skeleton', 0, 'Skeleton', 10, 20, 2);
                    this.add.existing(eSkel);
                    var eSnake = new Enemy(this, 400, 300, 'snake', 0, 'Dire Snake', 20, 10, 2);
                    this.add.existing(eSnake);
                    this.enemies = [eSkel, eSnake];
                }
                else if (rng == 3){
                    var eHorror = new Enemy(this, 500, 200, 'horror', 0, 'Elder Horror', 100, 20, 3);
                    this.add.existing(eHorror);
                    this.enemies = [eHorror];
                }

                this.hero = [player];
                //this.enemies = [eSkel, eSnake];
                this.units = this.hero.concat(this.enemies); //Puts everything into one list
                
                this.index = -1; // currently active unit
                
                this.scene.run("UIScene");        
            },

            nextTurn: function() {  
                // if we have victory or game over
                var battleState = this.checkEndBattle();
                if(battleState === "Victory") {  
                    player.expGain();
                    hpText.setText("HP: " + player.hp);
                    this.cameras.main.fadeOut(500);         
                    var timeEvent = this.time.addEvent({delay: 500, callback: this.exitBattle, callbackScope: this});
                    return;
                }
                if(battleState === "GameOver") {
                    this.cameras.main.fadeOut(300);
                    this.scene.remove('UIScene');
                    var timeEvent = this.time.addEvent({delay: 400, callback: this.gameOverMan, callbackScope: this});
                }
                do {
                    // currently active unit
                    this.index++;
                    // if there are no more units, we start again from the first one
                    if(this.index >= this.units.length) {
                        this.index = 0;
                    }            
                } while(!this.units[this.index].living);
                // if its player hero
                if(this.units[this.index] instanceof PlayerCharacter) {
                    // we need the player to select action and then enemy
                    this.events.emit("ActionSelect", this.index);
                } else { // else if its enemy unit
                    // call the enemy's attack function 
                    this.units[this.index].attack(this.hero[0]); 
                    hpText.setText("HP: " + player.hp); 
                    this.cameras.main.shake(100);
                    this.sound.play("Attack");
                    // add timer for the next turn, so will have smooth gameplay
                    this.time.addEvent({ delay: 3000, callback: this.nextTurn, callbackScope: this });
                }
            },

            checkEndBattle: function() {        
                var victory = true;
                // if all enemies are dead we have victory
                for(var i = 0; i < this.enemies.length; i++) {
                    if(this.enemies[i].living)
                        victory = false;
                }
                var gameOver = true;
                // if hero is dead we have game over
                if(this.hero[0].living)
                    gameOver = false;
                
                if(victory) {return "Victory";}
                else if(gameOver) {return "GameOver";}
                else {return "Continue";}
            },

            endBattle: function() {       
                // clear state, remove sprites
                this.enemies.length = 0;
                for(var i = 0; i < this.enemies.length; i++) {
                    // link item
                    this.enemies[i].destroy();            
                }
                this.units.length = 0;
                // sleep the UI
                this.scene.sleep('UIScene');
                // return to WorldScene and sleep current BattleScene
                this.scene.switch('WorldScene');
            },

            receivePlayerSelection: function(action, target) {
                if(action == 'attack') {            
                    this.units[this.index].attack(this.enemies[target]);              
                    this.sound.play("Attack");
                }
                else if(action == 'heal') {
                    this.units[this.index].heal();
                    hpText.setText("HP: " + player.hp);
                    this.sound.play("Spell");
                }
                else if(action == 'Firebolt') {
                    this.units[this.index].firebolt(this.enemies[target]);
                    this.sound.play("Spell");
                }
                this.time.addEvent({ delay: 3000, callback: this.nextTurn, callbackScope: this });        
            },

            gameOverMan: function() {
                this.scene.start('EndScene');
                this.soundFX.stop();
            }
        });

        var UIScene = new Phaser.Class({

            Extends: Phaser.Scene,

            initialize:

            function UIScene ()
            {
                Phaser.Scene.call(this, { key: 'UIScene' });
            },

            create: function ()
            {    
                this.graphics = this.add.graphics();
                this.graphics.lineStyle(1, 0xffffff);
                this.graphics.fillStyle(0x031f4c, 1);        
                this.graphics.strokeRect(2, 430, 210, 205);
                this.graphics.fillRect(2, 430, 210, 205);
                this.graphics.strokeRect(214, 430, 210, 205);
                this.graphics.fillRect(214, 430, 210, 205);
                this.graphics.strokeRect(426, 430, 210, 205);
                this.graphics.fillRect(426, 430, 210, 205);

                // basic container to hold all menus
                this.menus = this.add.container();
                
                this.actionsMenu = new ActionsMenu(18, 430, this);           
                this.spellsMenu = new SpellsMenu(230, 430, this);            
                this.enemiesMenu = new EnemiesMenu(442, 430, this);   
                
                // the currently selected menu 
                this.currentMenu = this.actionsMenu;
                
                // add menus to the container
                this.menus.add(this.actionsMenu);
                this.menus.add(this.spellsMenu);
                this.menus.add(this.enemiesMenu);

                this.battleScene = this.scene.get('BattleScene');

                this.input.keyboard.on('keydown', this.onKeyInput, this);
                this.battleScene.events.on("ActionSelect", this.onActionSelect, this);
                this.events.on("ActionSelect", this.onActionSelect, this);
                this.events.on("SelectSpells", this.onSelectSpells, this);
                this.events.on("SelectEnemies", this.onSelectEnemies, this);
                this.events.on("Enemy", this.onEnemy, this);
                // when the scene receives wake event
                this.sys.events.on('wake', this.createMenu, this);
                
                // the message describing the current action
                this.message = new Message(this, this.battleScene.events);
                this.add.existing(this.message);        
                
                this.createMenu();
            },

            createMenu: function() {
                // map enemies menu items to enemies
                var enemies = this.battleScene.enemies;
                this.enemiesMenu.remap(enemies);
                this.spellsMenu.remap(player.spells);
                // first move
                this.battleScene.nextTurn(); 
            },

            onKeyInput: function(event) {
                if(this.currentMenu && this.currentMenu.selected) {
                    if(event.code === "ArrowUp") {
                        this.currentMenu.moveSelectionUp();
                        this.sound.play("Select");
                    } else if(event.code === "ArrowDown") {
                        this.currentMenu.moveSelectionDown();
                        this.sound.play("Select");
                    } else if(event.code === "ArrowLeft" || event.code === "Shift") {
                        this.currentMenu.back();
                        this.sound.play("Back");
                    } else if(event.code === "Space" || event.code === "ArrowRight") {
                        this.currentMenu.confirm();
                        this.sound.play("Confirm");
                    } 
                }
            },

            onActionSelect: function() {
                this.currentMenu = this.actionsMenu;
                this.actionsMenu.select(0);
            },

            onSelectSpells: function() {
                this.currentMenu = this.spellsMenu;
                this.spellsMenu.select(0);
            },

            onSelectEnemies: function(action) {
                this.currentMenu = this.enemiesMenu;
                this.enemiesMenu.select(0);
                this.enemiesMenu.setAction(action);
            },

            onEnemy: function(action, index) {
                this.actionsMenu.deselect();
                this.spellsMenu.deselect();
                this.enemiesMenu.deselect();
                this.currentMenu = null;
                this.battleScene.receivePlayerSelection(action, index);
            },
        });

        var EndScene = new Phaser.Class({
            Extends: Phaser.Scene,
            initialize:

            function EndScene() {
                Phaser.Scene.call(this, {key: 'EndScene'});
            },
            create: function() {
                this.cameras.main.fadeIn(300);
                this.soundFX = this.sound.add("GameOver", {loop: "true"});
                this.soundFX.setVolume(0.5);
                this.soundFX.play();
                this.add.text(150, 200, "GAME OVER", {fontSize: '60px', fill: '#ff0000'});
            }
        });

        var config = {
        type: Phaser.AUTO,
        parent: 'content',
        width: 640,
        height: 640,
        zoom: 1,
        pixelArt: true,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 }
            }
        },
        scene: [
            BootScene,
            WorldScene,
            BattleScene,
            UIScene,
            EndScene
        ]
        };
        var game = new Phaser.Game(config);

        var Unit = new Phaser.Class({
            Extends: Phaser.GameObjects.Sprite,
        
            initialize:
        
            function Unit(scene, x, y, texture, frame, type, hp, damage) {
                Phaser.GameObjects.Sprite.call(this, scene, x, y, texture, frame)
                this.type = type;
                this.maxHp = this.hp = hp;
                this.damage = damage; // default damage     
                this.living = true;         
                this.menuItem = null;         
            },
            setMenuItem: function(item) {
                this.menuItem = item;
            },
            attack: function(target) {
                if(target.living) {
                    target.takeDamage(this.damage);
                    this.scene.events.emit("Message", this.type + " attacks " + target.type + " for " + this.damage + " damage");
                }
            },    
            takeDamage: function(damage) {
                this.hp -= damage;
                if(this.hp <= 0) {
                    this.hp = 0;
                    if(this.menuItem != null) {
                        this.menuItem.unitKilled();
                    }
                    this.living = false;
                    this.visible = false;   
                    this.menuItem = null;
                }
                else if(this.hp > this.maxHp) {
                    this.hp = this.maxHp;
                }
            }   
        });

        var Enemy = new Phaser.Class({
            Extends: Unit,
        
            initialize:
            function Enemy(scene, x, y, texture, frame, type, hp, damage, size) {
                Unit.call(this, scene, x, y, texture, frame, type, hp, damage);
                this.size = size;
            }
        });

        var PlayerCharacter = new Phaser.Class({
            Extends: Unit,
        
            initialize:
            function PlayerCharacter(scene, x, y, texture, frame, type, hp, damage) {
                Phaser.GameObjects.Sprite.call(this, scene, x, y, texture, frame)
                this.type = type;
                this.maxHp = this.hp = hp;
                this.damage = damage;     
                this.living = true;         
                this.menuItem = null;
                this.setScale(2);
                this.spellDamage = damage + 5;
                this.exp = 0;
                this.level = 1;
                this.spells = ["Firebolt"];
            },

            expGain: function() {
                this.exp += 1;
                if (this.exp == 3) {
                    this.exp = 0;
                    this.level += 1;
                    this.spellDamage += 5;
                    this.maxHp += 10;
                    this.hp = this.maxHp;
                    this.scene.events.emit("Message", "Level Up! You are now Level " + this.level + "!");
                }
            },

            heal: function() {
                this.takeDamage(-50);
                this.scene.events.emit("Message", this.type + " heals 50 health");
            },

            firebolt: function(target) {
                if(target.living) {
                    target.takeDamage(this.spellDamage);
                    this.scene.events.emit("Message", this.type + " used Firebolt on " + target.type + " for "+ this.spellDamage + " damage");
                }
            }
        });

        var MenuItem = new Phaser.Class({
            Extends: Phaser.GameObjects.Text,
            
            initialize:
                    
            function MenuItem(x, y, text, scene) {
                Phaser.GameObjects.Text.call(this, scene, x, y, text, { color: '#ffffff', align: 'left', fontSize: 25});
            },
            
            select: function() {
                this.setColor('#f8ff38');
            },
            
            deselect: function() {
                this.setColor('#ffffff');
            },

            // when the associated enemy or player unit is killed
            unitKilled: function() {
                this.active = false;
                this.visible = false;
            }
            
        });

        var Menu = new Phaser.Class({
            Extends: Phaser.GameObjects.Container,
            
            initialize:
                    
            function Menu(x, y, scene, heroes) {
                Phaser.GameObjects.Container.call(this, scene, x, y);
                this.menuItems = [];
                this.menuItemIndex = 0;
                this.x = x;
                this.y = y;        
                this.selected = false;
            },     
            addMenuItem: function(unit) {
                var menuItem = new MenuItem(0, this.menuItems.length * 20, unit, this.scene);
                this.menuItems.push(menuItem);
                this.add(menuItem); 
                return menuItem;
            },  
            // menu navigation 
            moveSelectionUp: function() {
                this.menuItems[this.menuItemIndex].deselect();
                do {
                    this.menuItemIndex--;
                    if(this.menuItemIndex < 0)
                        this.menuItemIndex = this.menuItems.length - 1;
                } while(!this.menuItems[this.menuItemIndex].active);
                this.menuItems[this.menuItemIndex].select();
            },
            moveSelectionDown: function() {
                this.menuItems[this.menuItemIndex].deselect();
                do {
                    this.menuItemIndex++;
                    if(this.menuItemIndex >= this.menuItems.length)
                        this.menuItemIndex = 0;
                } while(!this.menuItems[this.menuItemIndex].active);
                this.menuItems[this.menuItemIndex].select();
            },
            // select the menu as a whole and highlight the choosen element
            select: function(index) {
                if(!index)
                    index = 0;       
                this.menuItems[this.menuItemIndex].deselect();
                this.menuItemIndex = index;
                while(!this.menuItems[this.menuItemIndex].active) {
                    this.menuItemIndex++;
                    if(this.menuItemIndex >= this.menuItems.length)
                        this.menuItemIndex = 0;
                    if(this.menuItemIndex == index)
                        return;
                }        
                this.menuItems[this.menuItemIndex].select();
                this.selected = true;
            },
            // deselect this menu
            deselect: function() {        
                this.menuItems[this.menuItemIndex].deselect();
                this.menuItemIndex = 0;
                this.selected = false;
            },
            confirm: function() {
                // when the player confirms his slection, do the action
            },
            back: function() {
                //Go back to previous menu, if possible.
            },
            // clear menu and remove all menu items
            clear: function() {
                for(var i = 0; i < this.menuItems.length; i++) {
                    this.menuItems[i].destroy();
                }
                this.menuItems.length = 0;
                this.menuItemIndex = 0;
            }
        });

        var ActionsMenu = new Phaser.Class({
            Extends: Menu,
            
            initialize:
                    
            function ActionsMenu(x, y, scene) {
                Menu.call(this, x, y, scene);   
                this.addMenuItem('Attack');
                this.addMenuItem('Spell');
                this.addMenuItem('Heal');
            },
            confirm: function() {
                if(this.menuItemIndex === 0) {
                    this.scene.events.emit('SelectEnemies', 'attack');
                }
                else if (this.menuItemIndex === 1) {
                    this.scene.events.emit('SelectSpells');
                }
                else if (this.menuItemIndex === 2) {
                    this.scene.events.emit('Enemy', 'heal', 0);
                }
            },
            back: function() {
                this.menuItems[this.menuItemIndex].deselect();
                this.menuItemIndex = 0;
                this.menuItems[this.menuItemIndex].select();
            }
        });

        var SpellsMenu = new Phaser.Class({
            Extends: Menu,

            initialize:

            function SpellMenu(x, y, scene) {
                Menu.call(this, x, y, scene);
            },
            confirm: function() {
                this.scene.events.emit('SelectEnemies', 'Firebolt');
            },
            back: function() {
                this.menuItems[this.menuItemIndex].deselect();
                this.scene.events.emit('ActionSelect');
            },
            remap: function(spells) {
                this.clear();        
                for(var i = 0; i < spells.length; i++) {
                    var spell = spells[i];
                    this.addMenuItem(spell);            
                }
                this.menuItemIndex = 0;
            }
        });

        var EnemiesMenu = new Phaser.Class({
            Extends: Menu,
            
            initialize:

            function EnemiesMenu(x, y, scene) {
                Menu.call(this, x, y, scene); 
                this.action = 'attack';       
            },       
            setAction: function(action) {
                this.action = action;
            },
            confirm: function() {        
                this.scene.events.emit("Enemy", this.action, this.menuItemIndex);
            },
            back: function() {
                this.menuItems[this.menuItemIndex].deselect();
                if (this.action == 'attack') {
                    this.scene.events.emit('ActionSelect');
                }
                else {
                    this.scene.events.emit('SelectSpells');
                }
            },
            remap: function(units) {
                this.clear();        
                for(var i = 0; i < units.length; i++) {
                    var unit = units[i];
                    unit.setMenuItem(this.addMenuItem(unit.type));            
                }
                this.menuItemIndex = 0;
            }
        });

        var Message = new Phaser.Class({
            
            Extends: Phaser.GameObjects.Container,

            initialize:
            function Message(scene, events) {
                Phaser.GameObjects.Container.call(this, scene, 300, 90);
                var graphics = this.scene.add.graphics();
                this.add(graphics);
                graphics.lineStyle(1, 0xffffff, 0.8);
                graphics.fillStyle(0x031f4c, 0.3);        
                graphics.strokeRect(-150, -30, 300, 90);
                graphics.fillRect(-150, -30, 300, 90);
                this.text = new Phaser.GameObjects.Text(scene, 0, 0, "", { color: '#ffffff', align: 'center', fontSize: 20, wordWrap: { width: 300, useAdvancedWrap: true }});
                this.add(this.text);
                this.text.setOrigin(0.5);        
                events.on("Message", this.showMessage, this);
                this.visible = false;
            },
            showMessage: function(text) {
                this.text.setText(text);
                this.visible = true;
                if(this.hideEvent)
                    this.hideEvent.remove(false);
                this.hideEvent = this.scene.time.addEvent({ delay: 2000, callback: this.hideMessage, callbackScope: this });
            },
            hideMessage: function() {
                this.hideEvent = null;
                this.visible = false;
            }
            });
    </script>
</body>
</html>
